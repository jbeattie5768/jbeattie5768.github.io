<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Reading the Windows Registry with Python: A Case Study Using WinReg | Jonathan B</title>
<meta name="keywords" content="Python, WinReg, Windows Registry, PEP 514">
<meta name="description" content="
Table of Contents

Introduction
Background: What is the Windows Registry?
The Problem with Sample Code: Lessons from PEP 514
Exploring the Registry: Exporting and Analysing Data
Building a Better Registry Reader in Python
Practical Example: Using the Script
Key Takeaways
Try It Yourself


1. Introduction
Curiosity often leads to some of the most interesting projects. After reading about PEP 514 in the Astral UV documentation, I discovered that Python installations on Windows are registered in the Windows Registry. Intrigued, I tried the sample code from PEP 514, only to find it lacking. This post documents my journey to build a more robust, flexible Python script for reading Windows Registry values. Hopefully this may be useful for someone.">
<meta name="author" content="Jonathan B">
<link rel="canonical" href="https://jbeattie5768.github.io/posts/2025-08-01-accessing-the-windows-registry-with-python/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jbeattie5768.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jbeattie5768.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jbeattie5768.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jbeattie5768.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jbeattie5768.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://jbeattie5768.github.io/posts/2025-08-01-accessing-the-windows-registry-with-python/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://jbeattie5768.github.io/posts/2025-08-01-accessing-the-windows-registry-with-python/">
  <meta property="og:site_name" content="Jonathan B">
  <meta property="og:title" content="Reading the Windows Registry with Python: A Case Study Using WinReg">
  <meta property="og:description" content=" Table of Contents Introduction Background: What is the Windows Registry? The Problem with Sample Code: Lessons from PEP 514 Exploring the Registry: Exporting and Analysing Data Building a Better Registry Reader in Python Practical Example: Using the Script Key Takeaways Try It Yourself 1. Introduction Curiosity often leads to some of the most interesting projects. After reading about PEP 514 in the Astral UV documentation, I discovered that Python installations on Windows are registered in the Windows Registry. Intrigued, I tried the sample code from PEP 514, only to find it lacking. This post documents my journey to build a more robust, flexible Python script for reading Windows Registry values. Hopefully this may be useful for someone.">
  <meta property="og:locale" content="en-gb">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-08-01T00:00:00+00:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="WinReg">
    <meta property="article:tag" content="Windows Registry">
    <meta property="article:tag" content="PEP 514">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Reading the Windows Registry with Python: A Case Study Using WinReg">
<meta name="twitter:description" content="
Table of Contents

Introduction
Background: What is the Windows Registry?
The Problem with Sample Code: Lessons from PEP 514
Exploring the Registry: Exporting and Analysing Data
Building a Better Registry Reader in Python
Practical Example: Using the Script
Key Takeaways
Try It Yourself


1. Introduction
Curiosity often leads to some of the most interesting projects. After reading about PEP 514 in the Astral UV documentation, I discovered that Python installations on Windows are registered in the Windows Registry. Intrigued, I tried the sample code from PEP 514, only to find it lacking. This post documents my journey to build a more robust, flexible Python script for reading Windows Registry values. Hopefully this may be useful for someone.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jbeattie5768.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Reading the Windows Registry with Python: A Case Study Using WinReg",
      "item": "https://jbeattie5768.github.io/posts/2025-08-01-accessing-the-windows-registry-with-python/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reading the Windows Registry with Python: A Case Study Using WinReg",
  "name": "Reading the Windows Registry with Python: A Case Study Using WinReg",
  "description": " Table of Contents Introduction Background: What is the Windows Registry? The Problem with Sample Code: Lessons from PEP 514 Exploring the Registry: Exporting and Analysing Data Building a Better Registry Reader in Python Practical Example: Using the Script Key Takeaways Try It Yourself 1. Introduction Curiosity often leads to some of the most interesting projects. After reading about PEP 514 in the Astral UV documentation, I discovered that Python installations on Windows are registered in the Windows Registry. Intrigued, I tried the sample code from PEP 514, only to find it lacking. This post documents my journey to build a more robust, flexible Python script for reading Windows Registry values. Hopefully this may be useful for someone.\n",
  "keywords": [
    "Python", "WinReg", "Windows Registry", "PEP 514"
  ],
  "articleBody": " Table of Contents Introduction Background: What is the Windows Registry? The Problem with Sample Code: Lessons from PEP 514 Exploring the Registry: Exporting and Analysing Data Building a Better Registry Reader in Python Practical Example: Using the Script Key Takeaways Try It Yourself 1. Introduction Curiosity often leads to some of the most interesting projects. After reading about PEP 514 in the Astral UV documentation, I discovered that Python installations on Windows are registered in the Windows Registry. Intrigued, I tried the sample code from PEP 514, only to find it lacking. This post documents my journey to build a more robust, flexible Python script for reading Windows Registry values. Hopefully this may be useful for someone.\n2. Background: What is the Windows Registry? The Windows Registry is a hierarchical database that stores configuration settings and options for the operating system and installed applications in the form of Name:Value pairs. For Python developers, it’s especially relevant because Python installations are registered here (as per PEP 514), making it possible to discover and manage multiple Python versions programmatically.\nStructure of the Windows Registry The Windows Registry is similar to a file-system. The top-level nodes (hives) are known as root-keys, and each top-level root-key contains subkeys (like folders) and values (like files).\ngraph TD A[HKEY_CLASSES_ROOT] B[HKEY_CURRENT_USER] C[HKEY_LOCAL_MACHINE] D[HKEY_USERS] E[HKEY_CURRENT_CONFIG] F[Subkeys \u0026 Values] A --\u003e F B --\u003e F C --\u003e F D --\u003e F E --\u003e F Root Key Purpose HKEY_CLASSES_ROOT Stores information about registered applications, file associations, and COM objects. HKEY_CURRENT_USER Contains settings and preferences for the currently logged-in user. HKEY_LOCAL_MACHINE Holds configuration data for the local computer, including hardware and software. HKEY_USERS Contains user-specific configuration for all users on the system. HKEY_CURRENT_CONFIG Stores information about the current hardware profile used at system startup. A path is made from a root-key, keys, subkeys, and values. For example:\nHive (root key): HKEY_CURRENT_USER └── Key: Software └── Subkey: Python └── Subkey: Astral └── Subkey: CPython3.13.5 └── Value: InstallPath A key (or subkey) is like a folder—it can contain more subkeys and also values. CPython3.13.5 is a subkey. It can contain more subkeys (like InstallPath) and/or values (like Default, ExecutablePath, etc.). A value is a Name:Value pair stored inside a key. It does not contain further subkeys or values. InstallPath can be either a subkey (if it contains more subkeys/values) or a value (if it is just a Name:Value pair). The term “hive” is often used in documentation for the Windows Registry and seems to be a term specific to Windows, used by Microsoft to describe the files and top-level sections of the registry.\n3. The Problem with Sample Code: Lessons from PEP 514 When I first tried the two blocks of sample code from PEP 514, I expected it to work out of the box. Instead, it returned incomplete or misleading results:\nFrom looking at the Windows RegEdit application I knew this code was not reporting the correct values.\nReading the Python WinReg module documentation, we can get the code samples working by replacing the winreg.QueryValue() function call with the recommended winreg.QueryValueEx() function call and unpacking the returned value. This now gives:\nThat simple change, and removing the access mask to open the key (sample #1 only), has gotten us further. The fields are now looking better for those handled.\nThe Modified PEP 514 Sample Code is on my GitHub.\nI can see there is still more information we can access for the Python entries not handled by the sample code though.\n4. Exploring the Registry: Exporting and Analysing Data To better understand the registry’s structure, I exported sections of it using the Windows regedit.exe application and analysed the resulting files in the REPL. This helped me see the variety of data types and key/value patterns present.\nThe regedit.exe application does not allow you to export (dump) the whole registry as a single text file. You have to export the registry piecemeal, which in itself is a bit of a warning sign that there is a lot of data.\nFor my system, there can be a large number of keys to traverse depending on the root HKEY chosen:\nFilename File Size Line Count Key Count regdump_HKEY_CURRENT_CONFIG.txt 3.65 (KB) 58 12 regdump_HKEY_CURRENT_USER.txt 73.45 (MB) 611842 18402 regdump_HKEY_USERS.txt 100.40 (MB) 898276 35469 regdump_HKEY_CLASSES_ROOT.txt 122.69 (MB) 1931975 201571 regdump_HKEY_LOCAL_MACHINE.txt 553.31 (MB) 7558804 529983 Totals 849.85 (MB) 11,000,955 785,437 I’m not looking for much, just some idea of what we have. The following code is an example of what was run in the REPL as I was exploring the data, but it is runnable as a script on my GitHub. Python is quite capable of handling all these files simultaneously:\nExample: Analysing Exported Registry Files # file_analyse.py import fileinput from pprint import pprint tuple_of_files = ( \"regdump_HKEY_CLASSES_ROOT.txt\", \"regdump_HKEY_CURRENT_CONFIG.txt\", \"regdump_HKEY_CURRENT_USER.txt\", \"regdump_HKEY_LOCAL_MACHINE.txt\", \"regdump_HKEY_USERS.txt\", ) # There are some 'locale' characters that will not work for UTF-8 with fileinput.input(files=tuple_of_files, encoding=\"utf-16\") as fid: data = list(fid) # What Can we find out about Keys keynames = [] for this_line in data: if this_line.startswith(\"Key Name:\"): # Caution: Keys can have whitespace keynames.append(this_line.split(\"Key Name:\")[1].strip()) print(f\"Key Count: {len(keynames)}\\n\") pprint(keynames[:12]) # Print 1st 12 # Likely the longest and deepest key-paths are the same... longest_path = max(keynames, key=len) print(f\"\\nLongest key-path is {len(longest_path)} characters.\") print(f\"With {len(longest_path.split('\\\\'))} keys in it:\\n\") print(longest_path) # The actual key-path deepest_path = max(keynames, key=lambda x: len(x.split(\"\\\\\"))) print(f\"\\nDeepest key-path is {len(deepest_path)} characters.\") print(f\"With {len(deepest_path.split('\\\\'))} keys in it:\\n\") print(deepest_path) # The actual key-path # So as we thought, Key Names are like paths # i.e., the path is made up of keys and subkeys ... # other code available on GitHub Example summary of my registry key statistics Line Count: 11000955 Lines Blank: 2017686 ...which accounts for 18.34% of all lines ...removed blank lines, which has reduced line count by 18.34% Updated Line Count: 8983269 Key Count: 785437 Longest key-path is 407 characters. With 28 keys in it Deepest key-path is 407 characters. Duplicate Keys = False HKEYS listed: {'HKEY_CLASSES_ROOT', 'HKEY_CURRENT_CONFIG' 'HKEY_CURRENT_USER', 'HKEY_LOCAL_MACHINE', 'HKEY_USERS'} Types found: {'REG_BINARY', 'REG_DWORD', 'REG_EXPAND_SZ', 'REG_FULL_RESOURCE_DESCRIPTOR', 'REG_MULTI_SZ', 'REG_NONE', 'REG_QWORD', 'REG_RESOURCE_LIST', 'REG_RESOURCE_REQUIREMENTS_LIST', 'REG_SZ', 'REG_UNKNOWN'} The most common Class Name entries (Name, Count): [('\\n', 783641), ('REG_SZ\\n', 1090), ('Shell\\n', 694), ('Network ComputerName\\n', 2), ('1aa506ff\\n', 2), ('adda2636\\n', 2), ('5c15e5ed\\n', 2), ('2c356ba6\\n', 2), ('DynDRootClass\\n', 2)] There are a lot of keys (\u003e780k) and the longest key-path is long (28 keys or 407 characters). There is one value Type not defined in the Python WinReg module, which is REG_UNKNOWN. This appears when the Type is just an undefined hex value. We can either print the hex value or follow suit and use REG_UNKNOWN.\nClass Name entries appear in the exported text files, but not in the RegEdit application itself. I think this is the RegEdit exporter being clever by cross-referencing the Class, ClassID and ClassGuid ‘Name’ entries defined elsewhere in the registry.\nUpdate: I’ve subsequently confirmed that I cannot access anything named ‘Class Name’ in the registry with the Python WinReg module, and therefore ignoring these is a safe thing to do.\nI’m only dealing with 64-bit Windows, so I’m not worrying about accessing 32-bit applications. You may need to investigate further if you have to worry about 32-bit access – see Accessing an Alternate Registry View for more information.\nThe simplest Python WinReg code I could write to read a value:\nimport winreg key_handle = winreg.OpenKeyEx( winreg.HKEY_CURRENT_USER, # Root key \"Software\\\\Python\\\\PythonCore\", # Subkey access=winreg.KEY_READ, # Default is KEY_READ ) # Read known named value for the given subkey # Ignore value_type, we do nothing with it value, value_type = winreg.QueryValueEx(key_handle, \"DisplayName\",) print(f\"SubKey value: DisplayName='{value}'\") # \"key_handle\" object closed automatically when the object is destroyed # Alternatively use \"winreg.CloseKey()\", or better still a Context Manager There is a winreg.QueryInfoKey() function that returns the number of sub-keys and number of values for the passed key-path. You could then read each value (in a for-loop) with the winreg.QueryValueEx() function.\nAlternatively there is the preferred winreg.EnumKey() and winreg.EnumValue() functions that retrieve the name/value of one subkey each time they are called. These are typically called repeatedly until an OSError exception is raised, indicating no more values are available.\nThe latter is preferable for traversing a key-path.\n5. Building a Better Registry Reader in Python I set out to write a script that can:\nRead any registry key or value, not just Python-related ones Traverse subkeys recursively Handle errors gracefully..somewhat Be easily extended for new use cases We will define some design caveats first:\nWe will only be connecting locally, otherwise see winreg.ConnectRegistry(). Read Only, I don’t want to write to the Registry (Danger!) 64-bit only Print results to the console only, can redirect to file on the console if needed Use the REG_UNKNOWN type for undefined type values Command Line (CLI) use, but also programmatically callable One root-key at a time on CLI – can programmatically call more if needed Allow specific subkeys to be ignored - helps overcome permission issues and errors in the registry All the source code is available in the GitHub Repository: winreg_read.\nGetting Keys and Values I like the sample code method of using yield. Not keen on having the counter, so we can use recursion instead:\n# DO NOT DO THIS def get_keys(hkey, path, index=0): try: yield winreg.EnumKey(winreg.OpenKey(hkey, path), index) yield from get_keys(hkey, path, index+1) except OSError as err: pass Okay, bad idea #1 complete! Turns out this causes a RecursionError.\nWhat I did not realise was that Python has a recursion limit (sys.getrecursionlimit()), and using recursion in the Keys and Values functions meant we exceeded that limit (RecursionError exception), even for moderately-short traversals. You can change the recursion limit (sys.setrecursionlimit(n)), but I was not keen on doing so. So I went back to the counter method.\nThis was also the time I became concerned about key handles leaking for deep traversals.\nThe code is perhaps less Pedantic Pythonic, but it’s probably clearer to understand with the counter method anyway!\n# USE THIS for get_keys() and get_values() def get_keys(hkey, path): \"\"\"Yield all subkey names under the given HKey and sub-key path.\"\"\" try: # Explicitly close handles, otherwise risk of leaks for large traversals with winreg.OpenKey(hkey, path) as key: index = 0 while True: try: yield winreg.EnumKey(key, index) index += 1 except OSError: # Expected when no more keys to yield break except FileNotFoundError as err: msg = f\"\\n{path} is not a valid path\" raise FileNotFoundError(msg) from err except PermissionError as err: print(f\"{err}: Permission Error: you may need to run the script as Admin.\") We’ve added some exception protection for invalid paths, and some of the Registry may not be accessible to the user.\nTraversing Subkeys via Recursion We want:\nflowchart TD A[1: Function Entry - Traverse Key-Path] --\u003e B[2: Get Values for Key-Path] B --\u003e C{3: For each Subkey in get_keys} C -- No more Subkeys --\u003e CC[4: Continue] C-- For each Subkey --\u003eD[5: Build Subkey-Path] D--\u003e E[6: Get Values for Subkey-Path] E --\u003e F{7: For each Sub-Subkey-Path in get_keys} F -- No more Sub-Subkeys --\u003e FF[8: Continue] F -- For each Sub-Subkey --\u003e G[9: Build Sub-Subkey-Path] G --\u003e H[10: Recursive call: Traverse Sub-Subkey-Path] H --\u003e A Printing Results I only care about printing to the console. The RegEdit application’s exported text files are close to what I want, but perhaps with just some tweaking:\nFull_Path\\Copyable_for_RegEdit TYPE NAME VALUE Full_Path\\Copyable_for_RegEdit\\Plus_Subkey TYPE NAME VALUE ...and so on... We’ve seen some of the paths can be huge (\u003e400 characters for my system), the empty line between paths will help identify blocks of subkey values when the console wraps these multi-key paths.\nYou can redirect the console output to a file and remove line-wrap in your editor if the wrapping bothers you.\nWe can set some constants for the TYPE-NAME-VALUE column spacing.\nArguments with ArgParse ArgParse is quick, simple and all we need. It can be extended as needed:\nusage: winreg_read.py [-h] [-e [EXCLUDE ...]] HKey Key-Path Traverse Windows Registry and Print the Values positional arguments: HKey Enter HKey, e.g. 'HKEY_CURRENT_USER' Key-Path Subkey-Path to traverse from, e.g. 'Software\\python' options: -h, --help show this help message and exit -e, --exclude [EXCLUDE ...] List of Key-Paths to exclude from being traversed, i.e., ignored. Expected to be '-e 'path1' 'pathn' Issues Found Non-CONSTANT Type Values:\nSome Type entries are numbers and not one of the Type constants. For those I use the REG_UNKNOWN type.\nForward Slash in Key Name:\nI wanted to normalise slashes from the user, using something like os.path.join(*path.title().replace(r\"/\", \"\\\\\").split(\"\\\\\")). But, at least one key in my Windows registry has forward slashes in it, and for the Windows registry you cannot have backslashes in a key name, e.g.\nHKEY_CURRENT_USER\\Software\\Classes\\AppUserModelId\\C:/ProgramData/ASUS/AsusSurvey/AsusSurvey.exe\nThe key is C:/ProgramData/ASUS/AsusSurvey/AsusSurvey.exe.\nSo instead, depend on the user knowing what they are doing [sic].\nNon-Standard Characters:\nThere are some locale names that threw a UnicodeDecodeError. I guess they did not match my console locale setting. Best to change your console default. For PowerShell, chcp 65001 (UTF-8) worked for me…or just don’t traverse those keys.\nPermission errors:\nWhen you open the RegEdit application it opens in Admin mode. There may be some keys you will need Admin permission to access. I catch and continue for those, but you may need to run the script as admin to access all the keys.\nWindows Registry Errors:\nThere are some entries in my Windows registry that do not work, even in the RegEdit application. Nothing I can do except fix the Windows Registry itself, or add those keys/paths to the exclude argument.\nFinal Tidy It’s important to know when to stop.\nYou can spend forever tweaking and twiddling. Use tools like Ruff to take the majority of decision-making out of your hands.\n6. Practical Example: Using the Script Let’s see the script in action. Suppose you want to list all Python installations or inspect a custom registry key. Here’s how you might use the script:\nCommand-line Examples uv run winreg_read.py \"HKEY_CURRENT_USER\" \"SOFTWARE\\Python\" uv run winreg_read.py \"HKEY_CURRENT_USER\" \"SOFTWARE\\Python\" \u003e HKCU_python.txt uv run winreg_read.py HKEY_LOCAL_MACHINE SOFTWARE\\Microsoft\\WindowsUpdate uv run winreg_read.py HKEY_USERS '' # Not recommended for all HKey types uv run winreg_read.py \"HKEY_CLASSES_ROOT\" \"\" -e \"WOW6432Node\" \"zune\" # No commas uv run winreg_read.py \"HKEY_CURRENT_CONFIG\" \"System\" -e \"System\\CurrentControlSet\\Enum\" \"System\\CurrentControlSet\\SERVICES\" # No commas Script Examples Example 1 Traverse a given HKEY and subkey-path:\n# import winreg # Instead, use the import via 'winreg_read'import import winreg_read hkey = winreg_read.winreg.HKEY_CURRENT_USER key_path = r\"software\\python\" winreg_read.traverse_winreg_for_values(hkey, key_path, None) Example 2 Display the Python versions available from all manufacturers for the current user:\nimport winreg_read as wrr hkey = wrr.winreg.HKEY_CURRENT_USER key_path = r\"software\\python\" # List Python versions for each available manufacturer for this_subkey in wrr.get_keys(hkey, key_path): print(f\"\\n{this_subkey.title()} Python Versions:\") for this_key in wrr.get_keys(hkey, '\\\\'.join([key_path, this_subkey])): print(f\"\\t{this_key}\") …and then if we wanted to see details of a particular Python version:\nwrr.traverse_winreg_for_values(hkey, \"software\\\\python\\\\Astral\\\\CPython3.14.0b4\", None) 7. Key Takeaways Python is progressing fast, sample code becomes outdated quickly The Windows Registry is a powerful resource for automation and discovery Python’s winreg module can be used for much more than just reading Python installation information Reading a Registry Value Use winreg.OpenKey() to open a key Use winreg.QueryValueEx() to read a value Writing to the Registry Always back up the registry before making changes Use winreg.CreateKey() or winreg.OpenKey() with write access Use winreg.SetValueEx() to set a value Deleting a Registry Key or Value Use winreg.DeleteKey() or winreg.DeleteValue() for cleanup or automation 8. Try It Yourself Try out the script, experiment with different keys, and share your findings or improvements.\nGitHub Repository: winreg_read source code\nModified PEP 514 Sample Code\nRegistry File Analysis Code Snippets\nPEP 514 – Python registration in the Windows registry\nPython Docs: WinReg Module\nMicrosoft Information: Windows Registry\n* AI has been used for checking spelling, grammar and technical details on this Blog post.\n",
  "wordCount" : "2592",
  "inLanguage": "en",
  "datePublished": "2025-08-01T00:00:00Z",
  "dateModified": "2025-08-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Jonathan B"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jbeattie5768.github.io/posts/2025-08-01-accessing-the-windows-registry-with-python/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jonathan B",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jbeattie5768.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jbeattie5768.github.io/" accesskey="h" title="Jonathan B (Alt + H)">Jonathan B</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jbeattie5768.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://jbeattie5768.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://jbeattie5768.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://jbeattie5768.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jbeattie5768.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://jbeattie5768.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Reading the Windows Registry with Python: A Case Study Using WinReg
    </h1>
    <div class="post-meta"><span title='2025-08-01 00:00:00 +0000 UTC'>August 1, 2025</span>&nbsp;·&nbsp;Jonathan B

</div>
  </header> 
  <div class="post-content"><hr>
<h2 id="table-of-contents">Table of Contents<a hidden class="anchor" aria-hidden="true" href="#table-of-contents">#</a></h2>
<ul>
<li><a href="#1-introduction">Introduction</a></li>
<li><a href="#2-background-what-is-the-windows-registry">Background: What is the Windows Registry?</a></li>
<li><a href="#3-the-problem-with-sample-code-lessons-from-pep-514">The Problem with Sample Code: Lessons from PEP 514</a></li>
<li><a href="#4-exploring-the-registry-exporting-and-analysing-data">Exploring the Registry: Exporting and Analysing Data</a></li>
<li><a href="#5-building-a-better-registry-reader-in-python">Building a Better Registry Reader in Python</a></li>
<li><a href="#6-practical-example-using-the-script">Practical Example: Using the Script</a></li>
<li><a href="#7-key-takeaways">Key Takeaways</a></li>
<li><a href="#8-try-it-yourself">Try It Yourself</a></li>
</ul>
<hr>
<h2 id="1-introduction">1. Introduction<a hidden class="anchor" aria-hidden="true" href="#1-introduction">#</a></h2>
<p>Curiosity often leads to some of the most interesting projects. After reading about <a href="https://peps.python.org/pep-0514/">PEP 514</a> in the Astral <a href="https://docs.astral.sh/uv/">UV</a> documentation, I discovered that Python installations on Windows are registered in the Windows Registry. Intrigued, I tried the sample code from PEP 514, only to find it lacking. This post documents my journey to build a more robust, flexible Python script for reading Windows Registry values. Hopefully this may be useful for someone.</p>
<p><img alt="Windows RegEdit Application showing Python user entries" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-2.png"></p>
<hr>
<h2 id="2-background-what-is-the-windows-registry">2. Background: What is the Windows Registry?<a hidden class="anchor" aria-hidden="true" href="#2-background-what-is-the-windows-registry">#</a></h2>
<p>The Windows Registry is a hierarchical database that stores configuration settings and options for the operating system and installed applications in the form of <em>Name:Value</em> pairs. For Python developers, it’s especially relevant because Python installations are registered here (as per PEP 514), making it possible to discover and manage multiple Python versions programmatically.</p>
<h3 id="structure-of-the-windows-registry">Structure of the Windows Registry<a hidden class="anchor" aria-hidden="true" href="#structure-of-the-windows-registry">#</a></h3>
<p>The Windows Registry is similar to a file-system. The top-level nodes (hives) are known as root-keys, and each top-level root-key contains subkeys (like folders) and values (like files).</p>
<pre class="mermaid">
  graph TD
    A[HKEY_CLASSES_ROOT]
    B[HKEY_CURRENT_USER]
    C[HKEY_LOCAL_MACHINE]
    D[HKEY_USERS]
    E[HKEY_CURRENT_CONFIG]
    F[Subkeys &amp; Values]

    A --&gt; F
    B --&gt; F
    C --&gt; F
    D --&gt; F
    E --&gt; F
</pre>

<table>
  <thead>
      <tr>
          <th>Root Key</th>
          <th>Purpose</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>HKEY_CLASSES_ROOT</td>
          <td>Stores information about registered applications, file associations, and COM objects.</td>
      </tr>
      <tr>
          <td>HKEY_CURRENT_USER</td>
          <td>Contains settings and preferences for the currently logged-in user.</td>
      </tr>
      <tr>
          <td>HKEY_LOCAL_MACHINE</td>
          <td>Holds configuration data for the local computer, including hardware and software.</td>
      </tr>
      <tr>
          <td>HKEY_USERS</td>
          <td>Contains user-specific configuration for all users on the system.</td>
      </tr>
      <tr>
          <td>HKEY_CURRENT_CONFIG</td>
          <td>Stores information about the current hardware profile used at system startup.</td>
      </tr>
  </tbody>
</table>
<p>A path is made from a root-key, keys, subkeys, and values. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Hive (root key): HKEY_CURRENT_USER  
</span></span><span style="display:flex;"><span>└── Key: Software  
</span></span><span style="display:flex;"><span>    └── Subkey: Python  
</span></span><span style="display:flex;"><span>        └── Subkey: Astral  
</span></span><span style="display:flex;"><span>            └── Subkey: CPython3.13.5  
</span></span><span style="display:flex;"><span>                └── Value: InstallPath
</span></span></code></pre></div><ul>
<li>A key (or subkey) is like a folder—it can contain more subkeys and also values.
<ul>
<li><em>CPython3.13.5</em> is a subkey. It can contain more subkeys (like <em>InstallPath</em>) and/or values (like <em>Default</em>, <em>ExecutablePath</em>, etc.).</li>
</ul>
</li>
<li>A value is a <em>Name:Value</em> pair stored inside a key. It does not contain further subkeys or values.
<ul>
<li><em>InstallPath</em> can be either a subkey (if it contains more subkeys/values) or a value (if it is just a <em>Name:Value</em> pair).</li>
</ul>
</li>
</ul>
<blockquote class="note"><p>The term &ldquo;<em>hive</em>&rdquo; is often used in documentation for the Windows Registry and seems to be a term specific to Windows, used by Microsoft to describe the files and top-level sections of the registry.</p></blockquote>
<hr>
<h2 id="3-the-problem-with-sample-code-lessons-from-pep-514">3. The Problem with Sample Code: Lessons from PEP 514<a hidden class="anchor" aria-hidden="true" href="#3-the-problem-with-sample-code-lessons-from-pep-514">#</a></h2>
<p>When I first tried the two blocks of <a href="https://peps.python.org/pep-0514/#sample-code">sample code from PEP 514</a>, I expected it to work out of the box. Instead, it returned incomplete or misleading results:</p>
<p><img alt="PEP 514 Sample Code #1" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-0.png">
<img alt="PEP 514 Sample Code #2" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-1.png"></p>
<p>From looking at the Windows RegEdit application I knew this code was not reporting the correct values.</p>
<p>Reading the Python <a href="https://docs.python.org/3/library/winreg.html">WinReg</a> module documentation, we can get the code samples working by replacing the <code>winreg.QueryValue()</code> function call with the recommended <code>winreg.QueryValueEx()</code> function call and unpacking the returned <em>value</em>. This now gives:</p>
<p><img alt="PEP 514 Sample Code Updated" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-3.png"></p>
<p>That simple change, and removing the access mask to open the key (sample #1 only), has gotten us further. The fields are now looking better for those handled.</p>
<p>The <a href="https://github.com/jbeattie5768/winreg_read/tree/main/pep514_sample_code">Modified PEP 514 Sample Code</a> is on my GitHub.</p>
<p>I can see there is still more information we can access for the Python entries not handled by the sample code though.</p>
<hr>
<h2 id="4-exploring-the-registry-exporting-and-analysing-data">4. Exploring the Registry: Exporting and Analysing Data<a hidden class="anchor" aria-hidden="true" href="#4-exploring-the-registry-exporting-and-analysing-data">#</a></h2>
<p>To better understand the registry’s structure, I exported sections of it using the Windows <code>regedit.exe</code> application and analysed the resulting files in the REPL. This helped me see the variety of data types and key/value patterns present.</p>
<p>The <code>regedit.exe</code> application does not allow you to export (dump) the whole registry as a single text file. You have to export the registry piecemeal, which in itself is a bit of a warning sign that there is a <strong>lot</strong> of data.</p>
<p>For my system, there can be a large number of keys to traverse depending on the root HKEY chosen:</p>
<table>
  <thead>
      <tr>
          <th>Filename</th>
          <th>File Size</th>
          <th>Line Count</th>
          <th>Key Count</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>regdump_HKEY_CURRENT_CONFIG.txt</td>
          <td>3.65 (KB)</td>
          <td>58</td>
          <td>12</td>
      </tr>
      <tr>
          <td>regdump_HKEY_CURRENT_USER.txt</td>
          <td>73.45 (MB)</td>
          <td>611842</td>
          <td>18402</td>
      </tr>
      <tr>
          <td>regdump_HKEY_USERS.txt</td>
          <td>100.40 (MB)</td>
          <td>898276</td>
          <td>35469</td>
      </tr>
      <tr>
          <td>regdump_HKEY_CLASSES_ROOT.txt</td>
          <td>122.69 (MB)</td>
          <td>1931975</td>
          <td>201571</td>
      </tr>
      <tr>
          <td>regdump_HKEY_LOCAL_MACHINE.txt</td>
          <td>553.31 (MB)</td>
          <td>7558804</td>
          <td>529983</td>
      </tr>
      <tr>
          <td><em>Totals</em></td>
          <td><em>849.85 (MB)</em></td>
          <td><em>11,000,955</em></td>
          <td><em>785,437</em></td>
      </tr>
  </tbody>
</table>
<p>I&rsquo;m not looking for much, just some idea of what we have. The following code is an example of what was run in the REPL as I was exploring the data, but it is runnable <a href="https://github.com/jbeattie5768/winreg_read/tree/main/utils">as a script on my GitHub</a>. Python is quite capable of handling all these files simultaneously:</p>
<h3 id="example-analysing-exported-registry-files">Example: Analysing Exported Registry Files<a hidden class="anchor" aria-hidden="true" href="#example-analysing-exported-registry-files">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># file_analyse.py</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> fileinput
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> pprint <span style="color:#f92672">import</span> pprint
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tuple_of_files <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;regdump_HKEY_CLASSES_ROOT.txt&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;regdump_HKEY_CURRENT_CONFIG.txt&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;regdump_HKEY_CURRENT_USER.txt&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;regdump_HKEY_LOCAL_MACHINE.txt&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;regdump_HKEY_USERS.txt&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># There are some &#39;locale&#39; characters that will not work for UTF-8</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">with</span> fileinput<span style="color:#f92672">.</span>input(files<span style="color:#f92672">=</span>tuple_of_files, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;utf-16&#34;</span>) <span style="color:#66d9ef">as</span> fid:
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> list(fid)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># What Can we find out about Keys</span>
</span></span><span style="display:flex;"><span>keynames <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> this_line <span style="color:#f92672">in</span> data:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> this_line<span style="color:#f92672">.</span>startswith(<span style="color:#e6db74">&#34;Key Name:&#34;</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Caution: Keys can have whitespace</span>
</span></span><span style="display:flex;"><span>        keynames<span style="color:#f92672">.</span>append(this_line<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34;Key Name:&#34;</span>)[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>strip())
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Key Count: </span><span style="color:#e6db74">{</span>len(keynames)<span style="color:#e6db74">}</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>pprint(keynames[:<span style="color:#ae81ff">12</span>])  <span style="color:#75715e"># Print 1st 12</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Likely the longest and deepest key-paths are the same...</span>
</span></span><span style="display:flex;"><span>longest_path <span style="color:#f92672">=</span> max(keynames, key<span style="color:#f92672">=</span>len)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Longest key-path is </span><span style="color:#e6db74">{</span>len(longest_path)<span style="color:#e6db74">}</span><span style="color:#e6db74"> characters.&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;With </span><span style="color:#e6db74">{</span>len(longest_path<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#39;</span>))<span style="color:#e6db74">}</span><span style="color:#e6db74"> keys in it:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(longest_path)  <span style="color:#75715e"># The actual key-path</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>deepest_path <span style="color:#f92672">=</span> max(keynames, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x: len(x<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span>)))
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Deepest key-path is </span><span style="color:#e6db74">{</span>len(deepest_path)<span style="color:#e6db74">}</span><span style="color:#e6db74"> characters.&#34;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;With </span><span style="color:#e6db74">{</span>len(deepest_path<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#39;</span>))<span style="color:#e6db74">}</span><span style="color:#e6db74"> keys in it:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>print(deepest_path)  <span style="color:#75715e"># The actual key-path</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># So as we thought, Key Names are like paths</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># i.e., the path is made up of keys and subkeys</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span> <span style="color:#75715e"># other code available on GitHub</span>
</span></span></code></pre></div><h3 id="example-summary-of-my-registry-key-statistics">Example summary of my registry key statistics<a hidden class="anchor" aria-hidden="true" href="#example-summary-of-my-registry-key-statistics">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Line Count: 11000955
</span></span><span style="display:flex;"><span>Lines Blank: 2017686
</span></span><span style="display:flex;"><span>...which accounts for 18.34% of all lines
</span></span><span style="display:flex;"><span>...removed blank lines, which has reduced line count by 18.34%
</span></span><span style="display:flex;"><span>Updated Line Count: 8983269
</span></span><span style="display:flex;"><span>Key Count: 785437
</span></span><span style="display:flex;"><span>Longest key-path is 407 characters.
</span></span><span style="display:flex;"><span>With 28 keys in it
</span></span><span style="display:flex;"><span>Deepest key-path is 407 characters.
</span></span><span style="display:flex;"><span>Duplicate Keys = False
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HKEYS listed:
</span></span><span style="display:flex;"><span>{&#39;HKEY_CLASSES_ROOT&#39;, &#39;HKEY_CURRENT_CONFIG&#39; &#39;HKEY_CURRENT_USER&#39;, &#39;HKEY_LOCAL_MACHINE&#39;, &#39;HKEY_USERS&#39;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Types found:
</span></span><span style="display:flex;"><span>{&#39;REG_BINARY&#39;, &#39;REG_DWORD&#39;, &#39;REG_EXPAND_SZ&#39;, &#39;REG_FULL_RESOURCE_DESCRIPTOR&#39;,
</span></span><span style="display:flex;"><span> &#39;REG_MULTI_SZ&#39;, &#39;REG_NONE&#39;, &#39;REG_QWORD&#39;, &#39;REG_RESOURCE_LIST&#39;,
</span></span><span style="display:flex;"><span> &#39;REG_RESOURCE_REQUIREMENTS_LIST&#39;, &#39;REG_SZ&#39;, &#39;REG_UNKNOWN&#39;}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>The most common Class Name entries (Name, Count):
</span></span><span style="display:flex;"><span>[(&#39;&lt;NO CLASS&gt;\n&#39;, 783641), (&#39;REG_SZ\n&#39;, 1090), (&#39;Shell\n&#39;, 694),
</span></span><span style="display:flex;"><span> (&#39;Network ComputerName\n&#39;, 2), (&#39;1aa506ff\n&#39;, 2), (&#39;adda2636\n&#39;, 2),
</span></span><span style="display:flex;"><span> (&#39;5c15e5ed\n&#39;, 2), (&#39;2c356ba6\n&#39;, 2), (&#39;DynDRootClass\n&#39;, 2)]
</span></span></code></pre></div><p>There are a <em>lot of keys</em> (&gt;780k) and the longest key-path is long (28 keys or 407 characters).
There is one value <em>Type</em> not defined in the Python <code>WinReg</code> module, which is <code>REG_UNKNOWN</code>. This appears when the <em>Type</em> is just an undefined hex value. We can either print the hex value or follow suit and use <code>REG_UNKNOWN</code>.</p>
<p><em>Class Name</em> entries appear in the exported text files, but not in the RegEdit application itself. I think this is the RegEdit exporter being clever by cross-referencing the <em>Class</em>, <em>ClassID</em> and <em>ClassGuid</em> &lsquo;<em>Name</em>&rsquo; entries defined elsewhere in the registry.<br>
<em><strong>Update</strong></em>: <em>I&rsquo;ve subsequently confirmed that I cannot access anything named &lsquo;Class Name&rsquo; in the registry with the Python WinReg module, and therefore ignoring these is a safe thing to do.</em></p>
<p>I&rsquo;m only dealing with 64-bit Windows, so I&rsquo;m not worrying about accessing 32-bit applications. You may need to investigate further if you have to worry about 32-bit access – see <a href="https://learn.microsoft.com/en-gb/windows/win32/winprog64/accessing-an-alternate-registry-view?redirectedfrom=MSDN">Accessing an Alternate Registry View</a> for more information.</p>
<p>The simplest Python WinReg code I could write to read a value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> winreg
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>key_handle <span style="color:#f92672">=</span> winreg<span style="color:#f92672">.</span>OpenKeyEx(
</span></span><span style="display:flex;"><span>    winreg<span style="color:#f92672">.</span>HKEY_CURRENT_USER,        <span style="color:#75715e"># Root key</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;Software</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Python</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">PythonCore&#34;</span>,  <span style="color:#75715e"># Subkey</span>
</span></span><span style="display:flex;"><span>    access<span style="color:#f92672">=</span>winreg<span style="color:#f92672">.</span>KEY_READ,          <span style="color:#75715e"># Default is KEY_READ</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Read known named value for the given subkey</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Ignore value_type, we do nothing with it</span>
</span></span><span style="display:flex;"><span>value, value_type <span style="color:#f92672">=</span> winreg<span style="color:#f92672">.</span>QueryValueEx(key_handle, <span style="color:#e6db74">&#34;DisplayName&#34;</span>,)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;SubKey value: DisplayName=&#39;</span><span style="color:#e6db74">{</span>value<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &#34;key_handle&#34; object closed automatically when the object is destroyed</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Alternatively use &#34;winreg.CloseKey()&#34;, or better still a Context Manager</span>
</span></span></code></pre></div><p>There is a <code>winreg.QueryInfoKey()</code> function that returns the number of sub-keys and number of values for the passed key-path. You could then read each value (in a <em>for-loop</em>) with the <code>winreg.QueryValueEx()</code> function.</p>
<p>Alternatively there is the preferred <code>winreg.EnumKey()</code> and <code>winreg.EnumValue()</code> functions that retrieve the name/value of one subkey each time they are called. These are typically called repeatedly until an <code>OSError</code> exception is raised, indicating no more values are available.</p>
<p>The latter is preferable for traversing a key-path.</p>
<h2 id="5-building-a-better-registry-reader-in-python">5. Building a Better Registry Reader in Python<a hidden class="anchor" aria-hidden="true" href="#5-building-a-better-registry-reader-in-python">#</a></h2>
<p>I set out to write a script that can:</p>
<ul>
<li>Read any registry key or value, not just Python-related ones</li>
<li>Traverse subkeys recursively</li>
<li>Handle errors gracefully..somewhat</li>
<li>Be easily extended for new use cases</li>
</ul>
<p>We will define some design caveats first:</p>
<ul>
<li>We will only be connecting locally, otherwise see <code>winreg.ConnectRegistry()</code>.</li>
<li>Read Only, I don&rsquo;t want to write to the Registry (Danger!)</li>
<li>64-bit only</li>
<li>Print results to the console only, can redirect to file on the console if needed</li>
<li>Use the <code>REG_UNKNOWN</code> type for undefined type values</li>
<li>Command Line (CLI) use, but also programmatically callable</li>
<li>One root-key at a time on CLI – can programmatically call more if needed</li>
<li>Allow specific subkeys to be ignored - helps overcome permission issues and errors in the registry</li>
</ul>
<hr>
<p>All the source code is available in the <a href="https://github.com/jbeattie5768/winreg_read">GitHub Repository: <code>winreg_read</code></a>.</p>
<hr>
<h3 id="getting-keys-and-values">Getting Keys and Values<a hidden class="anchor" aria-hidden="true" href="#getting-keys-and-values">#</a></h3>
<p>I like the sample code method of using <code>yield</code>. Not keen on having the counter, so we can use recursion instead:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># DO NOT DO THIS</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_keys</span>(hkey, path, index<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield</span> winreg<span style="color:#f92672">.</span>EnumKey(winreg<span style="color:#f92672">.</span>OpenKey(hkey, path), index)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">yield from</span> get_keys(hkey, path, index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">OSError</span> <span style="color:#66d9ef">as</span> err:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span></code></pre></div><p>Okay, <strong>bad idea #1</strong> complete! Turns out this causes a <strong><em>RecursionError</em></strong>.</p>
<p>What I did not realise was that Python has a recursion limit (<code>sys.getrecursionlimit()</code>), and using recursion in the Keys and Values functions meant we exceeded that limit (<code>RecursionError</code> exception), even for moderately-short traversals. You can change the recursion limit (<code>sys.setrecursionlimit(n)</code>), but I was not keen on doing so. So I went back to the counter method.<br>
This was also the time I became concerned about key handles leaking for deep traversals.</p>
<p>The code is perhaps less <del>Pedantic</del> Pythonic, but it&rsquo;s probably clearer to understand with the counter method anyway!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># USE THIS for get_keys() and get_values()</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_keys</span>(hkey, path):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;Yield all subkey names under the given HKey and sub-key path.&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Explicitly close handles, otherwise risk of leaks for large traversals</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">with</span> winreg<span style="color:#f92672">.</span>OpenKey(hkey, path) <span style="color:#66d9ef">as</span> key:
</span></span><span style="display:flex;"><span>            index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">yield</span> winreg<span style="color:#f92672">.</span>EnumKey(key, index)
</span></span><span style="display:flex;"><span>                    index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">OSError</span>:  <span style="color:#75715e"># Expected when no more keys to yield</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">FileNotFoundError</span> <span style="color:#66d9ef">as</span> err:
</span></span><span style="display:flex;"><span>        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">{</span>path<span style="color:#e6db74">}</span><span style="color:#e6db74"> is not a valid path&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">FileNotFoundError</span>(msg) <span style="color:#f92672">from</span> err
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">PermissionError</span> <span style="color:#66d9ef">as</span> err:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>err<span style="color:#e6db74">}</span><span style="color:#e6db74">: Permission Error: you may need to run the script as Admin.&#34;</span>)
</span></span></code></pre></div><p>We&rsquo;ve added some exception protection for invalid paths, and some of the Registry may not be accessible to the user.</p>
<h3 id="traversing-subkeys-via-recursion">Traversing Subkeys via Recursion<a hidden class="anchor" aria-hidden="true" href="#traversing-subkeys-via-recursion">#</a></h3>
<p>We want:</p>
<pre class="mermaid">
  flowchart TD
    A[1: Function Entry - Traverse Key-Path] --&gt; B[2: Get Values for Key-Path]
    B --&gt; C{3: For each Subkey in get_keys}
    C -- No more Subkeys --&gt; CC[4: Continue]
    C-- For each Subkey --&gt;D[5: Build Subkey-Path]
    D--&gt; E[6: Get Values for Subkey-Path]
    E --&gt; F{7: For each Sub-Subkey-Path in get_keys}
    F -- No more Sub-Subkeys --&gt; FF[8: Continue]
    F -- For each Sub-Subkey --&gt; G[9: Build Sub-Subkey-Path]
    G --&gt; H[10: Recursive call: Traverse Sub-Subkey-Path]
    H --&gt; A
</pre>

<h3 id="printing-results">Printing Results<a hidden class="anchor" aria-hidden="true" href="#printing-results">#</a></h3>
<p>I only care about printing to the console. The RegEdit application&rsquo;s exported text files are close to what I want, but perhaps with just some tweaking:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Full_Path\Copyable_for_RegEdit
</span></span><span style="display:flex;"><span>    TYPE      NAME      VALUE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Full_Path\Copyable_for_RegEdit\Plus_Subkey
</span></span><span style="display:flex;"><span>    TYPE      NAME      VALUE
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...and so on...
</span></span></code></pre></div><p>We&rsquo;ve seen some of the paths can be huge (&gt;400 characters for my system), the empty line between paths will help identify blocks of subkey values when the console wraps these multi-key paths.</p>
<p>You can redirect the console output to a file and remove line-wrap in your editor if the wrapping bothers you.</p>
<p>We can set some constants for the TYPE-NAME-VALUE column spacing.</p>
<h3 id="arguments-with-argparse">Arguments with ArgParse<a hidden class="anchor" aria-hidden="true" href="#arguments-with-argparse">#</a></h3>
<p><a href="https://docs.python.org/3/library/argparse.html">ArgParse</a> is quick, simple and all we need. It can be extended as needed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>usage: winreg_read.py [-h] [-e [EXCLUDE ...]] HKey Key-Path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Traverse Windows Registry and Print the Values
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>positional arguments:
</span></span><span style="display:flex;"><span>  HKey                  Enter HKey, e.g. &#39;HKEY_CURRENT_USER&#39;
</span></span><span style="display:flex;"><span>  Key-Path              Subkey-Path to traverse from, 
</span></span><span style="display:flex;"><span>                        e.g. &#39;Software\python&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>options:
</span></span><span style="display:flex;"><span>  -h, --help            show this help message and exit
</span></span><span style="display:flex;"><span>  -e, --exclude [EXCLUDE ...]
</span></span><span style="display:flex;"><span>                        List of Key-Paths to exclude from being traversed, 
</span></span><span style="display:flex;"><span>                        i.e., ignored. Expected to be &#39;-e &#39;path1&#39; &#39;pathn&#39;
</span></span></code></pre></div><h3 id="issues-found">Issues Found<a hidden class="anchor" aria-hidden="true" href="#issues-found">#</a></h3>
<ul>
<li>
<p><strong>Non-CONSTANT Type Values</strong>:<br>
Some Type entries are numbers and not one of the Type constants. For those I use the <code>REG_UNKNOWN</code> type.</p>
</li>
<li>
<p><strong>Forward Slash in Key Name</strong>:<br>
I wanted to normalise slashes from the user, using something like <code>os.path.join(*path.title().replace(r&quot;/&quot;, &quot;\\&quot;).split(&quot;\\&quot;))</code>. But, at least one key in my Windows registry has forward slashes in it, and for the Windows registry you cannot have backslashes in a key name, e.g.<br>
<code>HKEY_CURRENT_USER\Software\Classes\AppUserModelId\C:/ProgramData/ASUS/AsusSurvey/AsusSurvey.exe</code><br>
The key is <code>C:/ProgramData/ASUS/AsusSurvey/AsusSurvey.exe</code>.<br>
So instead, depend on the user knowing what they are doing <em>[sic]</em>.</p>
</li>
<li>
<p><strong>Non-Standard Characters</strong>:<br>
There are some locale names that threw a <code>UnicodeDecodeError</code>. I guess they did not match my console locale setting. Best to change your console default. For PowerShell, <code>chcp 65001</code> (UTF-8) worked for me&hellip;or just don&rsquo;t traverse those keys.</p>
</li>
<li>
<p><strong>Permission errors</strong>:<br>
When you open the <code>RegEdit</code> application it opens in Admin mode. There may be some keys you will need Admin permission to access. I catch and continue for those, but you may need to run the script as admin to access all the keys.</p>
</li>
<li>
<p><strong>Windows Registry Errors</strong>:<br>
There are some entries in my Windows registry that do not work, even in the <code>RegEdit</code> application. Nothing I can do except fix the Windows Registry itself, or add those keys/paths to the exclude argument.</p>
</li>
</ul>
<h3 id="final-tidy">Final Tidy<a hidden class="anchor" aria-hidden="true" href="#final-tidy">#</a></h3>
<p>It&rsquo;s important to know when to stop.<br>
You can spend forever tweaking and twiddling. Use tools like <a href="https://docs.astral.sh/ruff/">Ruff</a> to take the majority of decision-making out of your hands.</p>
<hr>
<h2 id="6-practical-example-using-the-script">6. Practical Example: Using the Script<a hidden class="anchor" aria-hidden="true" href="#6-practical-example-using-the-script">#</a></h2>
<p>Let’s see the script in action. Suppose you want to list all Python installations or inspect a custom registry key. Here’s how you might use the script:</p>
<h3 id="command-line-examples">Command-line Examples<a hidden class="anchor" aria-hidden="true" href="#command-line-examples">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-pwsh" data-lang="pwsh"><span style="display:flex;"><span>uv run winreg_read.py <span style="color:#e6db74">&#34;HKEY_CURRENT_USER&#34;</span> <span style="color:#e6db74">&#34;SOFTWARE\Python&#34;</span>
</span></span><span style="display:flex;"><span>uv run winreg_read.py <span style="color:#e6db74">&#34;HKEY_CURRENT_USER&#34;</span> <span style="color:#e6db74">&#34;SOFTWARE\Python&#34;</span> &gt; HKCU_python.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>uv run winreg_read.py HKEY_LOCAL_MACHINE SOFTWARE\Microsoft\WindowsUpdate
</span></span><span style="display:flex;"><span>uv run winreg_read.py HKEY_USERS <span style="color:#e6db74">&#39;&#39;</span>  <span style="color:#75715e"># Not recommended for all HKey types</span>
</span></span><span style="display:flex;"><span>uv run winreg_read.py <span style="color:#e6db74">&#34;HKEY_CLASSES_ROOT&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> -e <span style="color:#e6db74">&#34;WOW6432Node&#34;</span> <span style="color:#e6db74">&#34;zune&#34;</span>  <span style="color:#75715e"># No commas</span>
</span></span><span style="display:flex;"><span>uv run winreg_read.py <span style="color:#e6db74">&#34;HKEY_CURRENT_CONFIG&#34;</span> <span style="color:#e6db74">&#34;System&#34;</span> -e <span style="color:#e6db74">&#34;System\CurrentControlSet\Enum&#34;</span> <span style="color:#e6db74">&#34;System\CurrentControlSet\SERVICES&#34;</span>  <span style="color:#75715e"># No commas</span>
</span></span></code></pre></div><p><img alt="Example Console Output" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-7.png"></p>
<h3 id="script-examples">Script Examples<a hidden class="anchor" aria-hidden="true" href="#script-examples">#</a></h3>
<h4 id="example-1">Example 1<a hidden class="anchor" aria-hidden="true" href="#example-1">#</a></h4>
<p>Traverse a given HKEY and subkey-path:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># import winreg  # Instead, use the import via &#39;winreg_read&#39;import </span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> winreg_read
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hkey <span style="color:#f92672">=</span> winreg_read<span style="color:#f92672">.</span>winreg<span style="color:#f92672">.</span>HKEY_CURRENT_USER
</span></span><span style="display:flex;"><span>key_path <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;software\python&#34;</span>
</span></span><span style="display:flex; background-color:#3c3d38"><span>
</span></span><span style="display:flex;"><span>winreg_read<span style="color:#f92672">.</span>traverse_winreg_for_values(hkey, key_path, <span style="color:#66d9ef">None</span>)
</span></span></code></pre></div><p><img alt="Traverse a given HKEY and Subkey-Path" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-4.png"></p>
<h4 id="example-2">Example 2<a hidden class="anchor" aria-hidden="true" href="#example-2">#</a></h4>
<p>Display the Python versions available from all manufacturers for the current user:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> winreg_read <span style="color:#66d9ef">as</span> wrr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hkey <span style="color:#f92672">=</span> wrr<span style="color:#f92672">.</span>winreg<span style="color:#f92672">.</span>HKEY_CURRENT_USER
</span></span><span style="display:flex;"><span>key_path <span style="color:#f92672">=</span> <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;software\python&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># List Python versions for each available manufacturer</span>
</span></span><span style="display:flex; background-color:#3c3d38"><span><span style="color:#66d9ef">for</span> this_subkey <span style="color:#f92672">in</span> wrr<span style="color:#f92672">.</span>get_keys(hkey, key_path):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">{</span>this_subkey<span style="color:#f92672">.</span>title()<span style="color:#e6db74">}</span><span style="color:#e6db74"> Python Versions:&#34;</span>)
</span></span><span style="display:flex; background-color:#3c3d38"><span>    <span style="color:#66d9ef">for</span> this_key <span style="color:#f92672">in</span> wrr<span style="color:#f92672">.</span>get_keys(hkey, <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>join([key_path, this_subkey])):
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74">{</span>this_key<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p><img alt="List Python versions for each available manufacturer" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-5.png"></p>
<p>&hellip;and then if we wanted to see details of a particular Python version:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid;"><code class="language-python" data-lang="python"><span style="display:flex; background-color:#3c3d38"><span>wrr<span style="color:#f92672">.</span>traverse_winreg_for_values(hkey, <span style="color:#e6db74">&#34;software</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">python</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Astral</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">CPython3.14.0b4&#34;</span>, <span style="color:#66d9ef">None</span>)
</span></span></code></pre></div><p><img alt="&hellip;see details of a particular Python version" loading="lazy" src="/posts/2025-08-01-accessing-the-windows-registry-with-python/images/image-6.png"></p>
<hr>
<h2 id="7-key-takeaways">7. Key Takeaways<a hidden class="anchor" aria-hidden="true" href="#7-key-takeaways">#</a></h2>
<ul>
<li>Python is progressing fast, sample code becomes outdated quickly</li>
<li>The Windows Registry is a powerful resource for automation and discovery</li>
<li>Python’s <code>winreg</code> module can be used for much more than just reading Python installation information</li>
</ul>
<h3 id="reading-a-registry-value">Reading a Registry Value<a hidden class="anchor" aria-hidden="true" href="#reading-a-registry-value">#</a></h3>
<ul>
<li>Use <code>winreg.OpenKey()</code> to open a key</li>
<li>Use <code>winreg.QueryValueEx()</code> to read a value</li>
</ul>
<h3 id="writing-to-the-registry">Writing to the Registry<a hidden class="anchor" aria-hidden="true" href="#writing-to-the-registry">#</a></h3>
<ul>
<li>Always back up the registry before making changes</li>
<li>Use <code>winreg.CreateKey()</code> or <code>winreg.OpenKey()</code> with write access</li>
<li>Use <code>winreg.SetValueEx()</code> to set a value</li>
</ul>
<h3 id="deleting-a-registry-key-or-value">Deleting a Registry Key or Value<a hidden class="anchor" aria-hidden="true" href="#deleting-a-registry-key-or-value">#</a></h3>
<ul>
<li>Use <code>winreg.DeleteKey()</code> or <code>winreg.DeleteValue()</code> for cleanup or automation</li>
</ul>
<hr>
<h2 id="8-try-it-yourself">8. Try It Yourself<a hidden class="anchor" aria-hidden="true" href="#8-try-it-yourself">#</a></h2>
<p>Try out the script, experiment with different keys, and share your findings or improvements.</p>
<ul>
<li>
<p><a href="https://github.com/jbeattie5768/winreg_read">GitHub Repository: <code>winreg_read</code> source code</a></p>
</li>
<li>
<p><a href="https://github.com/jbeattie5768/winreg_read/tree/main/pep514_sample_code">Modified PEP 514 Sample Code</a></p>
</li>
<li>
<p><a href="https://github.com/jbeattie5768/winreg_read/tree/main/utils">Registry File Analysis Code Snippets</a></p>
</li>
<li>
<p><a href="https://peps.python.org/pep-0514/">PEP 514 – Python registration in the Windows registry</a></p>
</li>
<li>
<p><a href="https://docs.python.org/3/library/winreg.html">Python Docs: WinReg Module</a></p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users">Microsoft Information: Windows Registry</a></p>
</li>
</ul>
<hr>
<p><em>* AI has been used for checking spelling, grammar and technical details on this Blog post.</em></p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jbeattie5768.github.io/tags/python/">Python</a></li>
      <li><a href="https://jbeattie5768.github.io/tags/winreg/">WinReg</a></li>
      <li><a href="https://jbeattie5768.github.io/tags/windows-registry/">Windows Registry</a></li>
      <li><a href="https://jbeattie5768.github.io/tags/pep-514/">PEP 514</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://jbeattie5768.github.io/posts/2025-07-27-modernizing-python-development-my-switch-to-uv/">
    <span class="title">Next »</span>
    <br>
    <span>Modernizing Python Development: My Switch to UV</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://jbeattie5768.github.io/">Jonathan B</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>


</body>

</html>
